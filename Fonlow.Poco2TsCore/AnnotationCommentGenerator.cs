using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;

namespace Fonlow.Poco2Client
{
	/// <summary>
	/// Provide a dictionary of doc comment generators to translate an attribute object to doc comment. The client code should call Get().TryGetValue to get a generator.
	/// </summary>
	public sealed class AnnotationCommentGenerator
	{
		/// <summary>
		/// Generate doc comment with generators for each custom attribute
		/// </summary>
		/// <param name="forTS">For generating TS only docComment this should be true.</param>
		public AnnotationCommentGenerator(bool forTS = false)
		{
			if (forTS)
			{
				generator.Add(typeof(ObsoleteAttribute), a => //https://jsdoc.app/tags-deprecated
				{
					var obsoleteAttr = (ObsoleteAttribute)a;
					return GenerateObsoleteAttributeComments(obsoleteAttr); //no such doc comment needed for C#, since IDE will show obsolete info.
				});
			}

			//JsDoc does not support some regular expressions, not even with mechanism of eacaping.
			generator.Add(typeof(System.ComponentModel.DataAnnotations.RegularExpressionAttribute), a =>
			{
				var regularExpression = (System.ComponentModel.DataAnnotations.RegularExpressionAttribute)a;
				var pattern = forTS ? EscapeForJsDoc(regularExpression.Pattern) : regularExpression.Pattern;
				return String.Format(CultureInfo.CurrentCulture, "Regex pattern: {0}", pattern);
			});
		}

		/// <summary>
		/// Dictionary to provide doc comment helper functions for various .NET validation attributes.
		/// The key is the type of an attribute object. The client codes should call dic.TryGetValue.
		/// </summary>
		/// <returns></returns>
		public IDictionary<Type, Func<object, string>> Get()
		{
			return generator;
		}

		readonly Dictionary<Type, Func<object, string>> generator = new Dictionary<Type, Func<object, string>>
		{
			{ typeof(System.ComponentModel.DataAnnotations.RequiredAttribute), a => "Required. Null or empty is invalid." },
			{ typeof(System.Text.Json.Serialization.JsonRequiredAttribute), a => "JSON Required. Null or empty may be fine." },
			{ typeof(System.ComponentModel.DataAnnotations.RangeAttribute), a =>
				{
					var range = (System.ComponentModel.DataAnnotations.RangeAttribute)a;
					return String.Format(CultureInfo.CurrentCulture, "Range: inclusive between {0} and {1}", range.Minimum, range.Maximum);
				}
			},
			{ typeof(System.ComponentModel.DataAnnotations.MaxLengthAttribute), a =>
				{
					var maxLength = (System.ComponentModel.DataAnnotations.MaxLengthAttribute)a;
					return String.Format(CultureInfo.CurrentCulture, "Max length: {0}", maxLength.Length);
				}
			},
			{ typeof(System.ComponentModel.DataAnnotations.MinLengthAttribute), a =>
				{
					var minLength = (System.ComponentModel.DataAnnotations.MinLengthAttribute)a;
					return String.Format(CultureInfo.CurrentCulture, "Min length: {0}", minLength.Length);
				}
			},
			{ typeof(System.ComponentModel.DataAnnotations.LengthAttribute), a =>
				{
					var lengthAttr = (System.ComponentModel.DataAnnotations.LengthAttribute)a;
					return String.Format(CultureInfo.CurrentCulture, "Length min: {0}, max: {1}", lengthAttr.MinimumLength, lengthAttr.MaximumLength);
				}
			},
			{ typeof(System.ComponentModel.DataAnnotations.StringLengthAttribute), a =>
				{
					var strLength = (System.ComponentModel.DataAnnotations.StringLengthAttribute)a;
					return String.Format(CultureInfo.CurrentCulture, "String length: inclusive between {0} and {1}", strLength.MinimumLength, strLength.MaximumLength);
				}
			},
			{ typeof(System.ComponentModel.DataAnnotations.DataTypeAttribute), a =>
				{
					var dataType = (System.ComponentModel.DataAnnotations.DataTypeAttribute)a;
					return String.Format(CultureInfo.CurrentCulture, "Data type: {0}", dataType.CustomDataType ?? dataType.DataType.ToString());
				}
			},
			{ typeof(DescriptionAttribute), a =>
				{
					var dataType = (DescriptionAttribute)a;
					return String.Format(CultureInfo.CurrentCulture, "Description: {0}", dataType.Description);
				}
			}

		};

		public static string GenerateObsoleteAttributeComments(ObsoleteAttribute obsoleteAttr)
		{
			return $"@deprecated {obsoleteAttr.Message}" + (obsoleteAttr.IsError ? " ~ Is Error." : string.Empty);
		}


		/// <summary>
		/// Escapes a regex pattern so it can safely appear inside a JSDoc
		/// @pattern `...` annotation without breaking Compodoc or VS Code tooltips.
		/// </summary>
		/// <remarks>
		/// Generated by copilot
		/// </remarks>
		static string EscapeForJsDoc(string pattern)
		{
			if (pattern == null)
				return string.Empty;

			var sb = new System.Text.StringBuilder(pattern.Length * 2);

			foreach (var ch in pattern)
			{
				switch (ch)
				{
					case '`':
						// Backticks break fenced code blocks in JSDoc
						sb.Append("\\`");
						break;

					case '{':
						// Prevent JSDoc from interpreting {something} as a type
						sb.Append("\\{");
						break;

					case '}':
						sb.Append("\\}");
						break;

					case '*':
						// Prevent accidental list formatting inside comments
						sb.Append("\\*");
						break;

					case '@':
						// Prevent accidental @tag parsing
						sb.Append("\\@");
						break;

					case '/':
						// Only escape if your generator wraps the pattern in /.../
						// Otherwise leave it alone.
						sb.Append("\\/");
						break;

					default:
						sb.Append(ch);
						break;
				}
			}

			return sb.ToString();
		}
	}
}
